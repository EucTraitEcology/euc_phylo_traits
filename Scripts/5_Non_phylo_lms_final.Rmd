---
title: "Non-phylogenetic Analysis and Plots"
output: html_notebook
---

# Introduction

This notebook aims to fit ordinary linear regression models in order to determine the nature of the relationships between the 10 continuous (+ 1 categorical) traits WITHOUT assuming any phylogenetic affect (i.e. assuming independence of data points despite being measured in closely related species). This can then be compared to the similar analysis using pgls (script/notebook 4) to determine the effect of phylogeny on the results calculated. Since this is a simple linear regression, the parameters should be the same when the axes are reversed and hence only half the number of pairwise correlations need to be carried out for determining p-value and r-squared, though that is not true for the slope coefficient we also use so all axis arrangements were run anyway.

The dataset has been pruned to only include the 164 taxa used in the pgls analysis for comparability.

This notebook also aims to create network diagrams and an ellipse table to represent the results and compare to the phylogenetic analysis. These correspond to Figures 4 (exported filename 'networks_combined_r3_colorblind.pdf') and 5 (exported filename 'delta_c_sig.pdf') in the manuscript and supplementary Table S7.1 (raw data for every correlation measured in this script using OLS models; exported filename 'OLS_full_coefficients.csv') and supplementary Figures S7 (Ellipse Table of Pearson's R; exported filename 'basic_corrplot.pdf') and S8 (Alternate versions of the networks without aany (or as many) lines omitted; exported filename 'suppmat_networks.pdf').

# Required Packages, Functions, and Data

```{r}
# Packages
library(corrplot)
library(qgraph)
library(ggplot2)

# Functions

extract_P <- function(model) {
  # extracts the P-value for the slope coefficient of the independent variable in a bvariate correlation
  x <- summary(model)
  P <- x$coefficients[c(as.character(x$call$formula[[3]])), c('Pr(>|t|)')]
  return(P)
}

## the following allows extraction of the slope coefficient of a pgls regression model, especially useful when list-applied to a large number of models simlutaneously
extract_slope <- function(model) {
  x <- summary(model)
  x$coefficients[2,1]
}

## the following allows extraction of the standard error of the slope coefficient for a single independent variable (or maybe the first one mentioned if there are more than one but it is untested in those cases)
extract_SE <- function(model) { 
  x <- summary(model)
  s.e.val <- x$coefficients[c(as.character(x$call$formula[[3]])),c('Std. Error')]
  return(s.e.val)
}

## the following allows extraction of degrees of freedom I.E. NOT SAMPLE SIZE from models (and can be used to extract sample size if we remember to add +1 or +2 to the output accordingly)
extract_n <- function(model) {
  x <- summary(model)
  n <- x$df[[2]]
  return(n)
}

## the following is for extracting the calculated r-squared value from a pgls regression model, especially useful when list-applied to many models simultaneously
r_squared <- function(model) {
  x <- summary(model)
  x$r.squared
}

## the following provides a shortcut to rounding values to three decimal places
num_round <- function(x){
  x_num <- as.numeric(x)
  out <- round(x_num, 3)
  return(out)
}

# Data import
eucs.scaled.data <- read.csv("../Input_data/eucs_scaled_data.csv")
eucs.scaled.data <- subset(eucs.scaled.data, select = -c(X))

## the following are summary objects from the phylogenetic analysis for comparison
load("~/Dropbox/Eucs_phylo_traits/Input_data/matrix_r.RData")
load("~/Dropbox/Eucs_phylo_traits/Input_data/matrix_r_half.RData")
load("~/Dropbox/Eucs_phylo_traits/Input_data/sig_only_r_half.RData")
load("~/Dropbox/Eucs_phylo_traits/Input_data/network_r3_obj.RData")
load("~/Dropbox/Eucs_phylo_traits/Input_data/lambda_matrix.RData")
load("~/Dropbox/Eucs_phylo_traits/Input_data/lambda_matrix_half.RData")
load("~/Dropbox/Eucs_phylo_traits/Input_data/pgls_coeff_matrix.RData")
load("~/Dropbox/Eucs_phylo_traits/Input_data/pgls_coeff_matrix_half.RData")
load("~/Dropbox/Eucs_phylo_traits/Input_data/pgls_sig_models.RData")
load("~/Dropbox/Eucs_phylo_traits/Input_data/halving_logical.RData")
```


# Analysis

The data being used has been log-transformed and scaled as this was used in the pgls analysis for consistency. Also, this is standard since variation in the traits we are examining here is often logarithmic or at least is not made less-normally distributed upon logarithmic transformation.

## Trait-Trait Correlations

### Max. Height

```{r}
olm.mh.rh <- lm(max_height_m ~ relative_height_by_girth, data = eucs.scaled.data)
summary(olm.mh.rh)

olm.rh.mh <- lm(relative_height_by_girth ~ max_height_m, data = eucs.scaled.data)
summary(olm.rh.mh)
```
```{r}
olm.mh.sd <- lm(max_height_m ~ stem_density_g_per_ml, data = eucs.scaled.data)
summary(olm.mh.sd)

olm.std.mh <- lm(stem_density_g_per_ml ~ max_height_m, data = eucs.scaled.data)
summary(olm.std.mh)
```


```{r}
olm.mh.bark <- lm(max_height_m ~ relative_bt_by_girth, data = eucs.scaled.data)
summary(olm.mh.bark)

olm.bark.mh <- lm(relative_bt_by_girth ~ max_height_m, data = eucs.scaled.data)
summary(olm.bark.mh)
```

```{r}
olm.mh.sla <- lm(max_height_m ~ sla_mm2_per_mg, data = eucs.scaled.data)
summary(olm.mh.sla)

olm.sla.mh <- lm(sla_mm2_per_mg ~ max_height_m, data = eucs.scaled.data)
summary(olm.sla.mh)
```

```{r}
olm.mh.lfa <- lm(max_height_m ~ leaf_area_cm2, data = eucs.scaled.data)
summary(olm.mh.lfa)

olm.lfa.mh <- lm(leaf_area_cm2 ~ max_height_m, data = eucs.scaled.data)
summary(olm.lfa.mh)
```

```{r}
olm.mh.lms <- lm(max_height_m ~ leaf_mass_g, data = eucs.scaled.data)
summary(olm.mh.lms)

olm.lms.mh <- lm(leaf_mass_g ~ max_height_m, data = eucs.scaled.data)
summary(olm.lms.mh)
```

```{r}
olm.mh.fwl <- lm(max_height_m ~ fruit_wall_width_mm, data = eucs.scaled.data)
summary(olm.mh.fwl)

olm.fwl.mh <- lm(fruit_wall_width_mm ~ max_height_m, data = eucs.scaled.data)
summary(olm.fwl.mh)
```

```{r}
olm.mh.fms <- lm(max_height_m ~ fruit_mass_mg, data = eucs.scaled.data)
summary(olm.mh.fms)

olm.fms.mh <- lm(fruit_mass_mg ~ max_height_m, data = eucs.scaled.data)
summary(olm.fms.mh)
```

```{r}
olm.mh.sms <- lm(max_height_m ~ seed_mass_mg, data = eucs.scaled.data)
summary(olm.mh.sms)

olm.sms.mh <- lm(seed_mass_mg ~ max_height_m, data = eucs.scaled.data)
summary(olm.sms.mh)
```

### Relative Height

```{r}
olm.rh.std <- lm(relative_height_by_girth ~ stem_density_g_per_ml, data = eucs.scaled.data)
summary(olm.rh.std)

olm.std.rh <- lm(stem_density_g_per_ml ~ relative_height_by_girth, data = eucs.scaled.data)
summary(olm.std.rh)
```
RH and SD no longer significant relations now in either arrangement.

```{r}
olm.rh.bark <- lm(relative_height_by_girth ~ relative_bt_by_girth, data = eucs.scaled.data)
summary(olm.rh.bark)

olm.bark.rh <- lm(relative_bt_by_girth ~ relative_height_by_girth,data = eucs.scaled.data)
summary(olm.bark.rh)
```

```{r}
olm.rh.sla <- lm(relative_height_by_girth ~ sla_mm2_per_mg, data = eucs.scaled.data)
summary(olm.rh.sla)

olm.sla.rh <- lm(sla_mm2_per_mg ~ relative_height_by_girth, data = eucs.scaled.data)
summary(olm.sla.rh)
```

```{r}
olm.rh.lfa <- lm(relative_height_by_girth ~ leaf_area_cm2, data = eucs.scaled.data)
summary(olm.rh.lfa)

olm.lfa.rh <- lm(leaf_area_cm2 ~ relative_height_by_girth, data = eucs.scaled.data)
summary(olm.lfa.rh)
```

```{r}
olm.rh.lms <- lm(relative_height_by_girth ~ leaf_mass_g, data = eucs.scaled.data)
summary(olm.rh.lms)

olm.lms.rh <- lm(leaf_mass_g ~ relative_height_by_girth, data = eucs.scaled.data)
summary(olm.lms.rh)
```

```{r}
olm.rh.fwl <- lm(relative_height_by_girth ~ fruit_wall_width_mm, data = eucs.scaled.data)
summary(olm.rh.fwl)

olm.fwl.rh <- lm(fruit_wall_width_mm ~ relative_height_by_girth, data = eucs.scaled.data)
summary(olm.fwl.rh)
```

```{r}
olm.rh.fms <- lm(relative_height_by_girth ~ fruit_mass_mg, data = eucs.scaled.data) 
summary(olm.rh.fms)

olm.fms.rh <- lm(fruit_mass_mg ~ relative_height_by_girth, data = eucs.scaled.data)
summary(olm.fms.rh)
```

```{r}
olm.rh.sms <- lm(relative_height_by_girth ~ seed_mass_mg, data = eucs.scaled.data)
summary(olm.rh.sms)

olm.sms.rh <- lm(seed_mass_mg ~ relative_height_by_girth, data = eucs.scaled.data)
summary(olm.sms.rh)
```

### Stem Density

```{r}
olm.std.bark <- lm(stem_density_g_per_ml ~ relative_bt_by_girth, data = eucs.scaled.data)
summary(olm.std.bark)

olm.bark.std <- lm(relative_bt_by_girth ~ stem_density_g_per_ml, data = eucs.scaled.data)
summary(olm.bark.std)
```

```{r}
olm.std.sla <- lm(stem_density_g_per_ml ~ sla_mm2_per_mg, data = eucs.scaled.data)
summary(olm.std.sla)

olm.sla.std <- lm(sla_mm2_per_mg ~ stem_density_g_per_ml, data = eucs.scaled.data)
summary(olm.sla.std)
```

```{r}
olm.std.lfa <- lm(stem_density_g_per_ml ~ leaf_area_cm2, data = eucs.scaled.data)
summary(olm.std.lfa)

olm.lfa.std <- lm(leaf_area_cm2 ~ stem_density_g_per_ml, data = eucs.scaled.data)
summary(olm.lfa.std)
```


```{r}
olm.std.lms <- lm(stem_density_g_per_ml ~ leaf_mass_g, data = eucs.scaled.data)
summary(olm.std.lms)

olm.lms.std <- lm(leaf_mass_g ~ stem_density_g_per_ml, data = eucs.scaled.data)
summary(olm.lms.std)
```

```{r}
olm.std.fwl <- lm(stem_density_g_per_ml ~ fruit_wall_width_mm, data = eucs.scaled.data)
summary(olm.std.fwl)

olm.fwl.std <- lm(fruit_wall_width_mm ~ stem_density_g_per_ml, data = eucs.scaled.data)
summary(olm.fwl.std)
```

```{r}
olm.std.fms <- lm(stem_density_g_per_ml ~ fruit_mass_mg, data = eucs.scaled.data)
summary(olm.std.fms)

olm.fms.std <- lm(fruit_mass_mg ~ stem_density_g_per_ml, data = eucs.scaled.data)
summary(olm.fms.std)
```

```{r}
olm.std.sms <- lm(stem_density_g_per_ml ~ seed_mass_mg, data = eucs.scaled.data)
summary(olm.std.sms)

olm.sms.std <- lm(seed_mass_mg ~ stem_density_g_per_ml, data = eucs.scaled.data)
summary(olm.sms.std)
```



### Relative Bark Thickness

```{r}
olm.bark.sla <- lm(relative_bt_by_girth ~ sla_mm2_per_mg, data = eucs.scaled.data)
summary(olm.bark.sla)

olm.sla.bark <- lm(sla_mm2_per_mg ~ relative_bt_by_girth, data = eucs.scaled.data)
summary(olm.sla.bark)
```

```{r}
olm.bark.lfa <- lm(relative_bt_by_girth ~ leaf_area_cm2, data = eucs.scaled.data)
summary(olm.bark.lfa)

olm.lfa.bark <- lm(leaf_area_cm2 ~ relative_bt_by_girth, data = eucs.scaled.data)
summary(olm.lfa.bark)
```

```{r}
olm.bark.lms <- lm(relative_bt_by_girth ~ leaf_mass_g, data = eucs.scaled.data)
summary(olm.bark.lms)

olm.lms.bark <- lm(leaf_mass_g ~ relative_bt_by_girth, data = eucs.scaled.data)
summary(olm.lms.bark)
```


```{r}
olm.bark.fwl <- lm(relative_bt_by_girth ~ fruit_wall_width_mm, data = eucs.scaled.data)
summary(olm.bark.fwl)

olm.fwl.bark <- lm(fruit_wall_width_mm ~ relative_bt_by_girth, data = eucs.scaled.data)
summary(olm.fwl.bark)
```


```{r}
olm.bark.fms <- lm(relative_bt_by_girth ~ fruit_mass_mg, data = eucs.scaled.data)
summary(olm.bark.fms)

olm.fms.bark <- lm(fruit_mass_mg ~ relative_bt_by_girth, data = eucs.scaled.data)
summary(olm.fms.bark)
```


```{r}
olm.bark.sms <- lm(relative_bt_by_girth ~ seed_mass_mg, data = eucs.scaled.data)
summary(olm.bark.sms)

olm.sms.bark <- lm(seed_mass_mg ~ relative_bt_by_girth, data = eucs.scaled.data)
summary(olm.sms.bark)
```


### SLA

```{r}
olm.sla.lfa <- lm(sla_mm2_per_mg ~ leaf_area_cm2, data = eucs.scaled.data)
summary(olm.sla.lfa)

olm.lfa.sla <- lm(leaf_area_cm2 ~ sla_mm2_per_mg, data = eucs.scaled.data)
summary(olm.lfa.sla)
```


```{r}
olm.sla.lms <- lm(sla_mm2_per_mg ~ leaf_mass_g, data = eucs.scaled.data)
summary(olm.sla.lms)

olm.lms.sla <- lm(leaf_mass_g ~ sla_mm2_per_mg, data = eucs.scaled.data)
summary(olm.lms.sla)
```


```{r}
olm.sla.fwl <- lm(sla_mm2_per_mg ~ fruit_wall_width_mm, data = eucs.scaled.data)
summary(olm.sla.fwl)

olm.fwl.sla <- lm(fruit_wall_width_mm ~ sla_mm2_per_mg, data = eucs.scaled.data)
summary(olm.fwl.sla)
```

```{r}
olm.sla.fms <- lm(sla_mm2_per_mg ~ fruit_mass_mg, data = eucs.scaled.data)
summary(olm.sla.fms)

olm.fms.sla <- lm(fruit_mass_mg ~ sla_mm2_per_mg, data = eucs.scaled.data)
summary(olm.fms.sla)
```

```{r}
olm.sla.sms <- lm(sla_mm2_per_mg ~ seed_mass_mg, data = eucs.scaled.data)
summary(olm.sla.sms)

olm.sms.sla <- lm(seed_mass_mg ~ sla_mm2_per_mg, data = eucs.scaled.data)
summary(olm.sms.sla)
```

### Leaf Area

```{r}
olm.lfa.lms <- lm(leaf_area_cm2 ~ leaf_mass_g, data = eucs.scaled.data)
summary(olm.lfa.lms)

olm.lms.lfa <- lm(leaf_mass_g ~ leaf_area_cm2, data = eucs.scaled.data)
summary(olm.lms.lfa)
```

```{r}
olm.lfa.fwl <- lm(leaf_area_cm2 ~ fruit_wall_width_mm, data = eucs.scaled.data)
summary(olm.lfa.fwl)

olm.fwl.lfa <- lm(fruit_wall_width_mm ~ leaf_area_cm2, data = eucs.scaled.data)
summary(olm.fwl.lfa)
```

```{r}
olm.lfa.fms <- lm(leaf_area_cm2 ~ fruit_mass_mg, data = eucs.scaled.data)
summary(olm.lfa.fms)

olm.fms.lfa <- lm(fruit_mass_mg ~ leaf_area_cm2, data = eucs.scaled.data)
summary(olm.fms.lfa)
```

```{r}
olm.lfa.sms <- lm(leaf_area_cm2 ~ seed_mass_mg, data = eucs.scaled.data)
summary(olm.lfa.sms)

olm.sms.lfa <- lm(seed_mass_mg ~ leaf_area_cm2, data = eucs.scaled.data)
summary(olm.sms.lfa)
```


### Leaf Mass

```{r}
olm.lms.fwl <- lm(leaf_mass_g ~ fruit_wall_width_mm, data = eucs.scaled.data)
summary(olm.lms.fwl)

olm.fwl.lms <- lm(fruit_wall_width_mm ~ leaf_mass_g, data = eucs.scaled.data)
summary(olm.fwl.lms)
```

```{r}
olm.lms.fms <- lm(leaf_mass_g ~ fruit_mass_mg, data = eucs.scaled.data)
summary(olm.lms.fms)

olm.fms.lms <- lm(fruit_mass_mg ~ leaf_mass_g, data = eucs.scaled.data)
summary(olm.fms.lms)
```


```{r}
olm.lms.sms <- lm(leaf_mass_g ~ seed_mass_mg, data = eucs.scaled.data)
summary(olm.lms.sms)

olm.sms.lms <- lm(seed_mass_mg ~ leaf_mass_g, data = eucs.scaled.data)
summary(olm.sms.lms)
```


### Fruit Wall Width

```{r}
olm.fwl.fms <- lm(fruit_wall_width_mm ~ fruit_mass_mg, data = eucs.scaled.data)
summary(olm.fwl.fms)

olm.fms.fwl <- lm(fruit_mass_mg ~ fruit_wall_width_mm, data = eucs.scaled.data)
summary(olm.fms.fwl)
```

```{r}
olm.fwl.sms <- lm(fruit_wall_width_mm ~ seed_mass_mg, data = eucs.scaled.data)
summary(olm.fwl.sms)

olm.sms.fwl <- lm(seed_mass_mg ~ fruit_wall_width_mm, data = eucs.scaled.data)
summary(olm.sms.fwl)
```


### Fruit Mass

```{r}
olm.fms.sms <- lm(fruit_mass_mg ~ seed_mass_mg, data = eucs.scaled.data)
summary(olm.fms.sms)

olm.sms.fms <- lm(seed_mass_mg ~ fruit_mass_mg,data = eucs.scaled.data)
summary(olm.sms.fms)
```


So when does accounting for phylogeny decrease the effect size/certainty/proportion of variation accounted for?
  - Mh-stem and leaf traits decrease notably
      - mh-sd no longer significant
      - Mh-fww goes from significant to non-significant, though the actual change in measures of the strength of the relationship aren't that great
      -mh-lms becomes non-significant now
  - Mh-fm and sm, go from almost certain correlations to almost definitely not
  - all but sms and sd -w rh
  - all but lms, fww and fms with stem density
    -sd-lfa no longer significant
  - all bark correlations
    -bark-lms no longer significant
  - all sla- except lms and rep.traits
      -sla-lfa no longer significant

Those where accounting for phylogeny increased relationship strength:
  -sms-rh
  -sd-rh
  -sd-lms
  -sd-fms
  -sd-fww
  -sla-lms
  -sla-reproductive traits
  -lfa-reproductive traits
      -lfa-seed is now significant
      -lfa fruit wall now significant
  -lms-reproductive traits
  

Weird/inconsistent effects:
  -leaf area-lms increases in effect size but decreases in r-squared
  -fruit wall width-fruit mass slightly increases but remains almost identical
  -fww-sms increased effect size only
  -fms-sms inreased effect size but decreased r-squred
  
  
In general, OLS regression overestimates strength of relationships among habit and stem traits and underestimates them among the reproductive traits. Mostly the effects were not great enough to change statistical significance but there were a few cases where this changed:
  -max.height-sd no longer clearly significant
  -max.height-fruit wall width (fms and sms also no longer borderline)
  -max.height-leaf mass also no longer significant (using upper lambda model)
  -rbt-rh also now not significant (when using the upper lambda otherwise its ambiguous)
  -rbt-lms no longer significant (when using upper lambda)
  -stem.density-leaf area no longer significant
  -sla-lfa no longer significant
  
  -leaf area-seed mass now significant
  -leaf area-fruit wall width now significant
  
This is all for the orientation of the axes that were calculated for the original olms but just need to check any changes in significance that may be different depending on which way around the pgls was since that does occasionally change the significance.

lms-mh
rbt-rh (in the upper lambda)
sd-mh (already accounted for above as the way arounf corresponding to upper half lambda)
lms-bark

Hence rbt-rh is another relationship not previously accounted for and included within the upper lambda half we're going with that resulted in a change in significance, the rest already calculated above will be the same in both directions or will have chosen the upper lambda half arrangement of variables anyway.


### Lignouber-Only vs. Everything Else

```{r}
olm.mh.LO <- lm(max_height_m ~ LO2, data = eucs.scaled.data)
summary(olm.mh.LO)
```

```{r}
olm.rh.LO <- lm(relative_height_by_girth ~ LO2, data = eucs.scaled.data)
summary(olm.rh.LO)
```

```{r}
olm.sd.LO <- lm(stem_density_g_per_ml ~ LO2, data = eucs.scaled.data)
summary(olm.sd.LO)
```

```{r}
olm.rbt.LO <- lm(relative_bt_by_girth ~ LO2, data = eucs.scaled.data)
summary(olm.rbt.LO)
```

```{r}
olm.sla.LO <- lm(sla_mm2_per_mg ~ LO2, data = eucs.scaled.data)
summary(olm.sla.LO)
```

```{r}
olm.la.LO <- lm(leaf_area_cm2 ~ LO2, data = eucs.scaled.data)
summary(olm.la.LO)
```

```{r}
olm.lm.LO <- lm(leaf_mass_g ~ LO2, data = eucs.scaled.data)
summary(olm.lm.LO)
```

```{r}
olm.fww.LO <- lm(fruit_wall_width_mm ~ LO2, data = eucs.scaled.data)
summary(olm.fww.LO)
```

```{r}
olm.fm.LO <- lm(fruit_mass_mg ~ LO2, data = eucs.scaled.data)
summary(olm.fm.LO)
```

```{r}
olm.sm.LO <- lm(seed_mass_mg ~ LO2, data = eucs.scaled.data)
summary(olm.sm.LO)
```


## Extracting Coefficients from OLS Models

Here we create a dataframe of the models so that we can input this into custom extraction functions for the r2, slope, SE and P-values later. 

Before this can be done, however, we will need a model to represent the 'perfect fit' to be input at the diagonals. We can do this by effectively regressing a variable with itself disguised as a different variable (the lm() function does not allow regression of a variable with itself).

```{r}
# to regress a variable with itself, it needs to be regressed against another variable with a different name but the same data points, since the regression functions don't allow the regression of variables with the same name
eucs.scaled.data.doubled <- cbind(eucs.scaled.data, eucs.scaled.data[c("max_height_m", "relative_height_by_girth", "stem_density_g_per_ml", "relative_bt_by_girth", "sla_mm2_per_mg", "leaf_area_cm2", "leaf_mass_g", "fruit_mass_mg", "fruit_wall_width_mm", "seed_mass_mg")])

# now to rename the columns
names(eucs.scaled.data.doubled) <- c("taxon", "location", "second_location", "max_height_m", "relative_height_by_girth", "stem_density_g_per_ml", "relative_bt_by_girth", "sla_mm2_per_mg", "leaf_area_cm2", "leaf_mass_g", "fruit_mass_mg", "fruit_wall_width_mm", "seed_mass_mg", "Sprouter", "Stem_Sprouter", "Lignotuber_Sprouter", "Stem_Sprouter2", "Lignotuber_Only", "Sprouting_Type", "Sprouting_Type2", "Sprouting_Type3", "Sprouting_Type4","LO2", "Sieberi", "max_height_m2", "relative_height_by_girth2", "stem_density_g_per_ml2", "relative_bt_by_girth2", "sla_mm2_per_mg2", "leaf_area_cm22", "leaf_mass_g2", "fruit_mass_mg2", "fruit_wall_width_mm2", "seed_mass_mg2")  

# now need to run models of variables against themselves so that r-squared (and slope coefficient) can be 1 and can be placed in the list wherever required
perfect.fit <- lm(max_height_m ~ max_height_m2, data = eucs.scaled.data.doubled)
# names(perfect.fit$coefficients)[[2]] <- "max_height_m2" #to fix a new problem making the extract_P fucntion not work on this particular model becasue for some reason the variable had 'Y' at the end of its name in the coefficients dataframe from which the P-value is lifted
summary(perfect.fit)
```

```{r}
# the following first makes a list of all models with the same dependent variable, then construct a larger list of these smaller lists
olm.mh.list <- list(perfect.fit, olm.mh.rh, olm.mh.sd, olm.mh.bark, olm.mh.sla, olm.mh.lfa, olm.mh.lms, olm.mh.fwl, olm.mh.fms, olm.mh.sms, olm.mh.LO)

olm.rh.list <- list(olm.rh.mh, perfect.fit, olm.rh.std, olm.rh.bark, olm.rh.sla, olm.rh.lfa, olm.rh.lms, olm.rh.fwl, olm.rh.fms, olm.rh.sms, olm.rh.LO)

olm.std.list <- list(olm.std.mh, olm.std.rh, perfect.fit, olm.std.bark, olm.std.sla, olm.std.lfa, olm.std.lms, olm.std.fwl, olm.std.fms, olm.std.sms, olm.sd.LO)
  
olm.bark.list <- list(olm.bark.mh, olm.bark.rh, olm.bark.std, perfect.fit, olm.bark.sla, olm.bark.lfa, olm.bark.lms, olm.bark.fwl, olm.bark.fms, olm.bark.sms, olm.rbt.LO)

olm.sla.list <- list(olm.sla.mh, olm.sla.rh, olm.sla.std, olm.sla.bark, perfect.fit, olm.sla.lfa, olm.sla.lms, olm.sla.fwl, olm.sla.fms, olm.sla.sms, olm.sla.LO)

olm.lfa.list <- list(olm.lfa.mh, olm.lfa.rh, olm.lfa.std, olm.lfa.bark, olm.lfa.sla, perfect.fit, olm.lfa.lms, olm.lfa.fwl, olm.lfa.fms, olm.lfa.sms, olm.la.LO)

olm.lms.list <- list(olm.lms.mh, olm.lms.rh, olm.lms.std, olm.lms.bark, olm.lms.sla, olm.lms.lfa, perfect.fit, olm.lms.fwl, olm.lms.fms, olm.lms.sms, olm.lm.LO)

olm.fwl.list <- list(olm.fwl.mh, olm.fwl.rh, olm.fwl.std, olm.fwl.bark, olm.fwl.sla, olm.fwl.lfa, olm.fwl.lms, perfect.fit, olm.fwl.fms, olm.fwl.sms, olm.fww.LO)

olm.fms.list <- list(olm.fms.mh, olm.fms.rh, olm.fms.std, olm.fms.bark, olm.fms.sla, olm.fms.lfa, olm.fms.lms, olm.fms.fwl, perfect.fit, olm.fms.sms, olm.fm.LO)

olm.sms.list <- list(olm.sms.mh, olm.sms.rh, olm.sms.std, olm.sms.bark, olm.sms.sla, olm.sms.lfa, olm.sms.lms, olm.sms.fwl, olm.sms.fms, perfect.fit, olm.sm.LO)

olm.LO.list <- list(olm.mh.LO, olm.rh.LO, olm.sd.LO, olm.rbt.LO, olm.sla.LO, olm.la.LO, olm.lm.LO, olm.fww.LO, olm.fm.LO, olm.sm.LO, perfect.fit)

olm.traits.list <- list(olm.mh.list, olm.rh.list, olm.std.list, olm.bark.list, olm.sla.list, olm.lfa.list, olm.lms.list, olm.fwl.list, olm.fms.list, olm.sms.list, olm.LO.list) 
```


# Plots and Comparisons with PGLS

## Ellipse-Table (For supp.mat.)

Even though the majority of the plots and comparisons use parameters extracted from the regression models, it is useful to simply show how a basic Pearson's r calculation would conclude our traits are correlated. Hence, the following section separately calculates the Pearson's r values and presents them as a ellipse table rather than extracting them from the above list of models.

```{r}
# pre-calculating the (Pearson's r) correlation coefficients is better as the resulting matrix already has the correct row and col names as an input to other functions and we don't have to assign variable names later when using the corrplot function later
table.matrix <- cor(na.omit(eucs.scaled.data[,!names(eucs.scaled.data) %in% c("taxon", "dataset", "dataset2", "Sprouter", "Stem_Sprouter", "Lignotuber_Sprouter", "Stem_Sprouter2", "Lignotuber_Only", "Sprouting_Type", "Sprouting_Type2", "Sprouting_Type3", "Sprouting_Type4", "Sieberi")]))
table.matrix

colnames(table.matrix) <- c("MH", "RH", "SD", "RBT", "SLA", "LA", "LM", "FWW", "FM", "SM", "BOS")
rownames(table.matrix) <- colnames(table.matrix)
corrplot(table.matrix, method = "ellipse")

pdf("../Output_figures/basic_corrplot.pdf", height = 5, width = 7)
corrplot(table.matrix, method = "ellipse", tl.col = "black", tl.cex = 1.5, cl.cex = 1.5)
mtext("Correlation coefficient (Pearson's r)", side = 4, line = -0.5, cex = 1.5)
dev.off()
```


## Network Diagram

The following creates a network diagram using non-phylogenetically corrected basic Pearson's r correlation coefficients as the input.

```{r}
qgraph(table.matrix, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
```


Now to compare with the corresponding PGLS network diagram 

```{r}
# the OLS network diagram with Pearsons r input
qgraph(table.matrix, layout = 'spring', label.cex = 0.9, label.scale = FALSE)

# the PGLS network from the previous script with r extracted from models
qgraph(matrix.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
```


### Sqrt of r-squared of regression summary


The following section generates a network using regression model outputs by taking the square root of the r-squared extracted from each model. Then, we verify that this method is not particularly different from the r-values calculated using the cor function that directly calculates the Pearson' r correlation coefficient. These r values will be used in the final version of the OLS compared to the PGLS network calculated in a similar way.


```{r}
# to systematically extract the r-squared values from each of the olms fitted earlier
olm.reg.r2 <- lapply(olm.traits.list, function(model.list){
  unlist(lapply(model.list, r_squared))
})

# creating a matrix for the extracted r-values
## note the following is arranged such that column names correspond to dependent variables
olm.reg.r2 <- as.data.frame(olm.reg.r2)
colnames(olm.reg.r2) <- colnames(table.matrix)
row.names(olm.reg.r2) <- colnames(olm.reg.r2)
## need to transpose to flip so that row names are the dependent variables
olm.reg.r2 <- t(olm.reg.r2) 
## better for network diagram to have 0 along main diagonal, though having 1 in the diagonals is better for ellipse table earlier
diag(olm.reg.r2) <- 0 

# Now to verify that the slight differences in r2 for reciprocal models are effectively/computationally equal as we expect, i.e. the following should return 'TRUE' as differences are just due to differences in internal rounding methods of functions and the like
all.equal(as.data.frame(olm.reg.r2),as.data.frame(t(olm.reg.r2)))

# now to use the sign of extracted slope coefficients to give the r-values signs
## first to extract the slope coefficients of all mmodels systematically
olm.coeff <- lapply(olm.traits.list, function(model.list){
  unlist(lapply(model.list, extract_slope))
})

## then to create a matrix for slope coefficients
olm.coeff <- as.data.frame(olm.coeff)
colnames(olm.coeff) <- colnames(table.matrix)
row.names(olm.coeff) <- colnames(olm.coeff)
### again, we need to transpose so rows are dependent variables; remember the slopes do not form a symmetrical matrix, even though r and p values do
olm.coeff <- t(olm.coeff) 
### the following will be necessary for a later section, but more convenient to create it now
olm.coeff.abs <- abs(olm.coeff) 

## apply signs of slopes to r-values
olm.neg.slopes <- olm.coeff < 0
olm.reg.r <- sqrt(olm.reg.r2)
### keep in mind this is already a symmetrical matrix before taking the square root as r2 values don't depend on axis arrangement
olm.reg.r[olm.neg.slopes] <- -1*olm.reg.r[olm.neg.slopes] 
```


Now to observe the effects of differences in r on the network arrangement and, if desired export this single network. This version of the network will be exported later as part of supplementary Figure S8.


```{r}
qgraph(table.matrix, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
qgraph(olm.reg.r, layout = 'spring', label.cex = 0.9, label.scale = FALSE)


# # now to export this version of the figure if desired
# network.full.olm <- qgraph(olm.reg.r, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
# qgraph(network.full.olm, filetype = 'pdf', filename = "../Output_figures/olm_network_full", height = 15, width = 20, labels = colnames(sig.only.r.olm), label.cex = 2)
```

Most of the differences in the above networks appear to be due to the overall arrangement and orientation of the networks, which tends to be rather sensitive to small changes in input when using the qgraph function. Hence, visual plots may not be the best method to compare these methods of calculating r. However, the signs and strengths of the relationships do not appear quite as different, though we need to verify more concretely the extent to which this is the case.


```{r}
# for full matrix
sort(abs(table.matrix-olm.reg.r)) 
mean(abs(table.matrix-olm.reg.r)[!abs(table.matrix-olm.reg.r) == 1])
median(abs(table.matrix-olm.reg.r)[!abs(table.matrix-olm.reg.r) == 1])

# For what we'll actually show on the final network (i.e. omit |r| < 0.3 as stated below)
table.matrix2 <- table.matrix
table.matrix2[abs(table.matrix2) < 0.3] <- 0

olm.reg.r.2 <- olm.reg.r
olm.reg.r.2[abs(olm.reg.r.2) < 0.3] <- 0

sort(abs(table.matrix2-olm.reg.r.2)) 
mean(abs(table.matrix2-olm.reg.r.2)[!abs(table.matrix2-olm.reg.r.2)%in% c(1, 0) & abs(table.matrix2-olm.reg.r.2) < 0.3])
median(abs(table.matrix2-olm.reg.r.2)[!abs(table.matrix2-olm.reg.r.2) %in% c(1, 0) & abs(table.matrix2-olm.reg.r.2) < 0.3])
```

For the full unabridged data: 
The largest difference in magnitude was 0.125 in and was between FM-LA, but the next one was 0.097 (FM-BOS)  and then 0.087 (FM-LM) and then 0.072 (SLA-LM) and the rest were less. The mean and median differences were 0.03679 and 0.03342 respectively.
Only 15/55 relationships have difference in r values calculated via the two methods greater than 0.05 (magnitude for these varies between 0.052 and 0.125).

For the r > 0.3 data:
The largest difference in magnitude was 0.087 (FM-LM) and the next one was 0.066 (RBT-LA) and then 0.063 (SLA-FM) and the rest were less. The mean and median differences were 0.03028 and 0.02921 respectively.


### Significant Lines Only


This section is for interest and completeness only. Here we show the OLS network diagram without the relationships that weren't statistically significant.


```{r}
# to extract the p-vales from each model systematically
olm.P <- lapply(olm.traits.list, function(model.list){
  unlist(lapply(model.list, extract_P))
})

# now to reformat extracted p-values into a matrix with apprpriate titles
olm.P <- as.data.frame(olm.P)
colnames(olm.P) <- colnames(table.matrix)
row.names(olm.P) <- colnames(olm.P)
## now it's around the right way with the row indicating the dependent variable and column the independent variable
olm.P <- t(olm.P) 
## meant to be symmetrical since the r2 and P don't change when indep and dep variables get swapped, but if using the regression parameters instead of simply the Pearson's correlation coefficient
olm.P == t(olm.P) 
## TRUE, so the differences in values in mirrored positions are only computational and the matrix is in fact symmetrical along the diagonal. This means, as expected for OLS models, swapping the (in)dependent variables does not change the p-value.
all.equal(olm.P, t(olm.P)) 
# need to create matrix of logical values TRUE and FALSE
sig.models.olm <- olm.P < 0.05

# now to set all r-values for non-significant relationships to 0
olm.reg.r.sig.only <- olm.reg.r
olm.reg.r.sig.only[!sig.models.olm] <- 0

# to compare the OLS significant-relationships-only network to the full OLS network
qgraph(olm.reg.r.sig.only, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
qgraph(olm.reg.r, layout = 'spring', label.cex = 0.9, label.scale = FALSE)

# to compare the OLS significant-relationships-only network to the equivalent PGLS version
qgraph(olm.reg.r.sig.only, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
qgraph(sig.only.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
```


### Thinning Out Busy Edges

Removing non-significant relationships is useful but the diagram is still busy, even moreso than the PGLS version. We now have to remove more relationships: all those with |r| < 0.3 like we did for the PGLS version. We want to make them invisible but we don't want the node positions to move as if these relationships had never existed. I.e. we want to make some edges invisible but without changing node positions and without changing the edge widths of the remaining edges. Also, we need our final networks to have a more colorblind-friendly color scheme, so from now on we'll use the "theme = 'colorblind'" argument in each network.

As we found in the previous notebook/script, the in built argument of the qgraph function 'threshold' and 'minimum' remove edges between nodes with thickness below that value, but the former does so before recalculating all of the relative positions of the nodes as if the missing edges had weighting/strength/width of 0 (which drastically changes the shape of the network), whereas the latter preserves node position but re-scales the apparent width of the edges and sets the new 'zero width' to be the new value making many moderate relationships hard to see. Hene why we can;t just use either of these in built arguments.

```{r}
# First to remind ourselves what relationships should be in the final network
## note cannot regenerate the effective version of the r-matrix used if the subsetting was done as part of function arguments 'threshold' or 'minimum' rather than pre-making the altered r-matrix accordingly
qgraph(olm.reg.r, layout= 'spring', label.cex = 0.9, label.scale = FALSE, theme = 'colorblind', threshold = 0.30)

# now to remove lines from network that have |r| < 0.3
## to alter parameters of a network object, it is more convenient to name the object first
network.edge.rem.olm <- qgraph(olm.reg.r, layout= 'spring', label.cex = 0.9, label.scale = FALSE, theme = 'colorblind')
## note that nodes are numbered in order they appear as columns in the r-matrix, hence we can actually do this programmatically
network.edge.rem.olm$Edgelist$weight[abs(network.edge.rem.olm$Edgelist$weight) <0.3] <- 0

# plot comparison of this network with the full OLS network
qgraph(olm.reg.r, layout= 'spring', label.cex = 0.9, label.scale = FALSE, theme = 'colorblind')

# plot the comparison of this network with the PGLS equivalent to which it will be compared in our figure
plot(network.edge.rem)
plot(network.edge.rem.olm)
```


### Finalising Networks

#### Changing node colours and Label Parameters

```{r}
# note this objects we're about to alter is a character vector not a list
class(network.edge.rem$graphAttributes$Nodes$color)

## First to finalise the PGLS network
### the following sets the bacjground colors of the nodes to be the same for traits of a similar category
network.edge.rem$graphAttributes$Nodes$color <- c("#31688EFF", "#31688EFF", "#FDE725FF", "#FDE725FF", "#35B779FF", "#35B779FF", "#35B779FF", "#482475FF", "#482475FF", "#482475FF", "#FFFFFFFF")
### the following makes the test of the node labels for the reproductive traits white instead of black so it can be seen on a dark purple background
network.edge.rem$graphAttributes$Nodes$label.color <- c("black", "black", "black", "black", "black", "black", "black", "white", "white", "white", "black")
### the following sets the label text size as large as can fit inside the node when exported to pdf
network.edge.rem$graphAttributes$Nodes$label.cex <- 1.3
plot(network.edge.rem)

## Now to do the same to the OLS network
### the following sets the bacjground colors of the nodes to be the same for traits of a similar category
network.edge.rem.olm$graphAttributes$Nodes$color <- c("#31688EFF", "#31688EFF", "#FDE725FF", "#FDE725FF", "#35B779FF", "#35B779FF", "#35B779FF", "#482475FF", "#482475FF", "#482475FF", "#FFFFFFFF")
### the following makes the test of the node labels for the reproductive traits white instead of black so it can be seen on a dark purple background
network.edge.rem.olm$graphAttributes$Nodes$label.color <- c("black", "black", "black", "black", "black", "black", "black", "white", "white", "white", "black")
### the following sets the label text size as large as can fit inside the node when exported to pdf
network.edge.rem.olm$graphAttributes$Nodes$label.cex <- 1.3
plot(network.edge.rem.olm)

# to look the finalised versions before exporting
plot(network.edge.rem.olm)
plot(network.edge.rem)
```



#### Side-by-side networks

To create Figure 4 in the manuscript we need to plot both the finalised OLS and PGLS networks side by side (vertically in this case). We also determine that the minima and maxima of the relationships

```{r}
# to plot both networks side by side and export
pdf("../Output_figures/networks_combined_r3_colorblind.pdf", width = 8, height = 12)
par(mfrow = c(2,1))
plot(network.edge.rem.olm)
plot(network.edge.rem)
dev.off()

# checking what the min and max value of r are in each network to see if they're basically on the same scale anyway and it appears the mins and max's are similar enough that the line thickness on the two networks could be on the same scale. Here, 0.332 and 0.301 are minima and 0.907 and 0.904 are maxima respectively.
min(abs(olm.reg.r[olm.reg.r > 0.3]))
min(abs(matrix.r.half[matrix.r.half > 0.3]))

max(abs(olm.reg.r[olm.reg.r > 0.3]))
max(abs(matrix.r.half[matrix.r.half > 0.3 & matrix.r.half < 1]))

# also the true minima that are included in the scaling of edge widths (as we didn't rescale after removing weak relationships) are only different by 0.035 which isn't particularly large given the scale goes all the way up to 0.90-0.91
min(abs(olm.reg.r[olm.reg.r > 0]))
min(abs(matrix.r.half[matrix.r.half > 0]))
min(abs(olm.reg.r[olm.reg.r > 0])) - min(abs(matrix.r.half[matrix.r.half > 0]))
```


## Looking at Change in Relationships Upon Accounting for Phylogeny

While network diagrams are good for some aspects of comparison between LS and PGLS methods. Comparison between the networks in terms of which correlations (in/de)creased the most or least is difficult to see just from that. Hence, we need a clearer way to show this. We have opted for a tile diagram much like the ellipse table to show weakening or strengthening affect of accounting for phylogeny on trait correlations.

Initially, we run this using the overall formula r2(pgls) - r2(ols). However, since PGLS and OLS dont have comparable r2 values (PGLS has a 'pseudo-r2'), we resolved to use the absolute magnitude of the slope coefficient as a measure of relationship strength instead. There is a bit more noise in the slope coefficient than the r2 though.

Also, preliminary analyses verified that the following plot of the change in slope coefficient magnitude is not simply a plot of lambda intensity as the data is conical rather than linear; the greater the phylogenetic signal, the wider the range of change in relationship strength.


```{r}
# need to reformat the pgls coefficient matrix from previous analysis and take absolute value
## transpose to make sure dependent vars are the row names
coeff <- t(matrix.table.c)
colnames(coeff) <- row.names(coeff)
coeff.abs <- abs(coeff)

# now to extract the coefficients of the lm models and take the absolute value in order to subtract these values from the pgls coefficients magnitude
## olm.coeff.abs was created when slopes were first extracted from OLS models
delta.c <- as.matrix(coeff.abs - olm.coeff.abs)
corrplot(delta.c, method = "color")

# since the following matrices is not symmetrical, the tile graph above also will not be
plot(as.matrix(coeff))
plot(as.matrix(olm.coeff))
```

The lack of symmetry of the delta.c corrplot diagram is not necessarily an issue (i.e. it is not caused by lack of equivalence of formatting between the two matrices). But, it means this figure includes information for comparisons we have not included in the networks and it would be more consistent to only show data from the same models depicted in the network diagrams. Also, symmetrical matrices reveal patterns more easily on a visual basis.

```{r}
# now for the halving process of both PGLS and OLS slope coefficients

pgls.coeff.half <- matrix(NA, 11, 11)
pgls.coeff.half[log2] <- as.matrix(coeff)[log2]
pgls.coeff.half[!log2] <- t(as.matrix(coeff))[!log2]
rownames(pgls.coeff.half) <- rownames(coeff)
colnames(pgls.coeff.half) <- rownames(coeff)

olm.coeff.half <- matrix(NA, 11, 11)
olm.coeff.half[log2] <- as.matrix(olm.coeff)[log2]
olm.coeff.half[!log2] <- t(as.matrix(olm.coeff))[!log2]
rownames(olm.coeff.half) <- rownames(olm.coeff)
colnames(olm.coeff.half) <- rownames(olm.coeff)

# now to remake the plot of change in slope magnitude
delta.c.half <- abs(pgls.coeff.half) - abs(olm.coeff.half)
corrplot(delta.c.half, method = "color")

# compare with original non-symmetrical version
corrplot(delta.c, method = "color")
corrplot(delta.c.half, method = "color")

# largest magnitude on this plot is 0.333, hence why the colors are so light
max(abs(delta.c))
min(abs(delta.c))
```

#### Adding Change in Significance Status

In addition to just the change in magnitudes, adding any changes in significance status of the correlation/relationship.

```{r}
# since the significance matrices comes from extracted model p-values, they also need to be halved to determine if significance changed for the actual relationships we are depicting in the diagram (also because the pgls pvalues are not symmetrical whereas the ols p-values are)

sig.models.half <- matrix(NA, 11, 11)
sig.models.half[log2] <- sig.models[log2]
sig.models.half[!log2] <- t(sig.models)[!log2]
sig.models.half[is.na(sig.models.half) == TRUE] <-FALSE
rownames(sig.models.half) <- rownames(sig.models)
colnames(sig.models.half) <- rownames(sig.models.half)

# checking that this matrix is symmetrical as it should be
sig.models.half == t(sig.models.half)

# defining the change in significance status logical matrix
change.in.sig2 <- sig.models.half == sig.models.olm

# looking at it
change.in.sig2 
```


Losses of sig. upon accounting for phylogeny:
MH-LM
MH-FWW
RH-FWW
RBT-FWW
SLA-LA
SM-BOS

Gains of significance upon accounting for phylogeny:
SLA-LM
LA-FWW
LA-SM

We can use this matrix to add symbols over the top of this diagram to indicate when the change in slope magnitude was strong enough to change significance status. 


#### Finalising Fig. 5

We can, in addition to adding in a symbol to represent when a change in slope magnitude caused a change in significance status of the correlation, switch to a more colorblind friendly scheme, reduce the axis limit values to rescale/intensify the colors, and add labels.

```{r}
# good to know what the max and min values are to help rescale the the color gradient
max(delta.c.half) #~ 0.2
min(delta.c.half) #~ -0.33

# plot the finalised version of this plot
corrplot(delta.c.half, method = "shade", p.mat = !change.in.sig2, pch = 2, tl.col = "black", col.lim = c(-0.4,0.4), cl.length = 5)

pdf("../Output_figures/delta_c_sig.pdf", height = 7, width = 9)
corrplot(delta.c.half, method = "shade", p.mat = !change.in.sig2, pch = 2, tl.col = "black", tl.cex = 1.5, col.lim = c(-0.4,0.4), col = colorRampPalette(c("chocolate2", "chocolate2", "white", "cornflowerblue", "cornflowerblue"))(200), cl.length = 5, cl.cex = 1.6, cl.offset = 3)
mtext("Change in Effect Size when accounting for Phylogeny", side = 4, line = 0.5, cex = 1.5)
dev.off()
```


####  Checking if reciprocal differences in slope exceed S.E.

Is the difference between reciprocal-model slope coefficients always within the standard error (of the tips analysis results)? We know this will not be true for the PGLS analysis as lambda changes with the reciprocal as well and is an additional source of variation. This is important to verify that we aren't leaving out some vital info by only showing one of the pair of reciprocal models (where the model is the same except for which variable is the (in)dependent variable). We'll do this test just for the OLS data for now.

```{r}
# matrix of change in absolute value of slope for reciprocal 
diff.c.abs <- abs(olm.coeff - t(olm.coeff))

# the following shows there's a .088, .079, and .077 then the rest are less than .05
sort(diff.c.abs) 

# now for extracting the SE of the slope for each olm model
olm.coeff.SE <- lapply(olm.traits.list, function(model.list){
  unlist(lapply(model.list, extract_SE))
})

# creating a matrix of standard errors of slope coefficients
olm.coeff.SE <- as.data.frame(olm.coeff.SE)
colnames(olm.coeff.SE) <- colnames(table.matrix)
row.names(olm.coeff.SE) <- colnames(olm.coeff.SE)
olm.coeff.SE <- t(olm.coeff.SE) 

# 4 models (including any reciprocals/semi-duplicates) where the difference between the slope coefficient of the model and that of its reciprocal exceeds the standard error of the former model
sum(diff.c.abs > olm.coeff.SE) 

# note the difference matrix is symmetrical, but the the SE-matrix is not
```

The 4 differences in slope magnitude that were greater than the standard error were 0.077, 0.079, and 2 x 0.088. The models where are (RBT - LA and LA - RBT, RH - LA, and SD - LA (first two pairs are reciprocals of each other))

Three models above are not even the ones used as they happen to not be the ones that generated the higher lambda in the pgls so even our fig.5 tile diagram doesn't use them in a calculation. For the reciprocal (LA-RBT), the one we used happened to be the lower slope value than it's reciprocal as last time and as such is more conservative. Hence, even the occasions when we are showing only one pair of model's results where the pair differ, it does not negatively impact further analysis.



## Tables for Supp. Mat.

Now to finish extracting any further relevant OLS model parameters and export a table of the raw data that will become supplementary Table S7.1.

```{r}
# extracting degrees of freedom systematically
olm.n <- lapply(olm.traits.list, function(model.list){
  unlist(lapply(model.list, extract_n))
})

# creating a matrix of sample size from the degrees of freedom
olm.n <- as.data.frame(olm.n)
colnames(olm.n) <- colnames(table.matrix)
row.names(olm.n) <- colnames(olm.n)
olm.n <- t(olm.n)
olm.df <- olm.n
olm.n <- olm.df + 2

# good to know the min and max to state the range, also note the range is the same as for the PGLS analysis, 145-164
min(olm.n)
max(olm.n)
```


```{r}
# now to combine everything into a table

olm.coeff.tab <- as.data.frame(olm.coeff)

olm.coeff.SE.tab <- as.data.frame(olm.coeff.SE)

olm.combined.param <- data.frame('Slope' = paste(unlist(t(olm.coeff.tab)), unlist(t(olm.coeff.SE.tab)), sep = " Â± "), 'R_Squared' = unlist(as.data.frame(t(olm.reg.r2))), 'N' = unlist(as.data.frame(t(olm.n))), 'P_value' = unlist(as.data.frame(t(olm.P))))
ind.var<- data.frame('I.V.' = rep(c('MH', 'RH', 'SD', 'RBT', 'SLA', 'LA', 'LM', 'FWW', 'FM', 'SM', 'BOS'), times = 11))
olm.combined.param <- cbind(ind.var, olm.combined.param)
```


#### Fixing Rounding

We need to round all these numbers to 3 decimal places before exporting.

```{r}
# already loaded this object but I'll rename to preserve original
df <- olm.combined.param
df[, 'D.V.'] <- row.names(df)

# create a three column data frame with each component of the 'slope' separated by the space character
sep_slope <- data.frame(do.call('rbind', strsplit(as.character(df$Slope),
                                                  ' ', fixed = TRUE)))
# apply the num_round function to cols 1 and 3 but not 2
sep_slope <- data.frame(sep_slope[2], apply(sep_slope[c(1,3)],2,num_round))

# paste them back together after rounding
sep_slope$Slope <- paste(sep_slope$X1, sep_slope$X2, sep_slope$X3)

#final object binds the two character columns, the new slope and rounds the remaining that need it
df2 <- cbind(df[, c('D.V.', 'I.V.')],
             Slope = sep_slope$Slope,
             R_squared = num_round(df$R_Squared),
             N = df$N,
             P_value = num_round(df$P_value))

olm.combined.param2 <- df2

# now to export the final table
write.csv(olm.combined.param2, file = "../Output_figures/OLS_full_coefficients.csv", row.names = FALSE)
```

### Supp. Mat. Networks

Now to finalise and export the extra network diagrams that comprise supplementary figure S8.

```{r}
# finalising full already symmetrical olm network
network.full.olm <- qgraph(olm.reg.r, layout = 'spring', label.cex = 0.9, label.scale = FALSE, theme = 'colorblind')
network.full.olm$graphAttributes$Nodes$color <- c("#31688EFF", "#31688EFF", "#FDE725FF", "#FDE725FF", "#35B779FF", "#35B779FF", "#35B779FF", "#482475FF", "#482475FF", "#482475FF", "#FFFFFFFF")
network.full.olm$graphAttributes$Nodes$label.color <- c("black", "black", "black", "black", "black", "black", "black", "white", "white", "white", "black")
network.full.olm$graphAttributes$Nodes$label.cex <- 1.3

# finalising symmetrical version of pgls network
network.full.half.pgls <- qgraph(matrix.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE, theme = 'colorblind')
network.full.half.pgls$graphAttributes$Nodes$color <- c("#31688EFF", "#31688EFF", "#FDE725FF", "#FDE725FF", "#35B779FF", "#35B779FF", "#35B779FF", "#482475FF", "#482475FF", "#482475FF", "#FFFFFFFF")
network.full.half.pgls$graphAttributes$Nodes$label.color <- c("black", "black", "black", "black", "black", "black", "black", "white", "white", "white", "black")
network.full.half.pgls$graphAttributes$Nodes$label.cex <- 1.3

# finalising OLS network with non-significant relationships removed entirely
network.sig.only.olm <-qgraph(olm.reg.r.sig.only, layout = 'spring', label.cex = 0.9, label.scale = FALSE, theme = 'colorblind')
network.sig.only.olm$graphAttributes$Nodes$color <- c("#31688EFF", "#31688EFF", "#FDE725FF", "#FDE725FF", "#35B779FF", "#35B779FF", "#35B779FF", "#482475FF", "#482475FF", "#482475FF", "#FFFFFFFF")
network.sig.only.olm$graphAttributes$Nodes$label.color <- c("black", "black", "black", "black", "black", "black", "black", "white", "white", "white", "black")
network.sig.only.olm$graphAttributes$Nodes$label.cex <- 1.3

# finalising PGLS network with non-significant relationships removed entirely
network.sig.only.pgls <- qgraph(sig.only.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE, theme = 'colorblind')
network.sig.only.pgls$graphAttributes$Nodes$color <- c("#31688EFF", "#31688EFF", "#FDE725FF", "#FDE725FF", "#35B779FF", "#35B779FF", "#35B779FF", "#482475FF", "#482475FF", "#482475FF", "#FFFFFFFF")
network.sig.only.pgls$graphAttributes$Nodes$label.color <- c("black", "black", "black", "black", "black", "black", "black", "white", "white", "white", "black")
network.sig.only.pgls$graphAttributes$Nodes$label.cex <- 1.3

pdf('../Output_figures/suppmat_networks.pdf', width = 14, height = 10)
par(mfrow = c(2,2))
# the following are listed as the first two on the top row and the latter two in the bottom row
plot(network.full.olm)
plot(network.sig.only.olm)
plot(network.full.half.pgls)
plot(network.sig.only.pgls)
dev.off()
```

# Saving Files for Later Analyses

```{r}
# this is for the multiple comparisons later
saveRDS(olm.P, file = "../Input_data/OLM_P.rds")
saveRDS(olm.combined.param,'../Input_data/OLM_coefficients_full.rds')
```


