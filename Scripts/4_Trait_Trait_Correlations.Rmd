---
title: "PGLS Trait-Trait Correlations"
output: html_notebook
---
# Introduction

The purpose of this notebook is to run pgls trait-trait correlations and visualise the outputs. It requires that a phylogentic tree and trait-dataset in wide-format be already made and supplied.

# Analysis

## Data Preparation

```{r fig.height = 30, fig.width = 15}
#input the phylogenetc hypothesis to be used
tree <- read.tree("Input_data/final_tree.txt")
tree$tip.label <- gsub("_", " ", tree$tip.label)
eucs.test.tree <- tree 
eucs.test.tree <- compute.brlen(eucs.test.tree, method = "Grafen", power = 1) #give the tree branch lengths that
#plot_dim1(eucs.test.tree)

#Preparing the matching objects that allow the package to link data frames to tree tips

##for the untransformed data
eucs.test <- eucs.test <- comparative.data(phy = eucs.test.tree, data = eucs.data, names.col = taxon, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE)
eucs.test$dropped$unmatched.rows # only the five taxa not on the tree droped so thats good
eucs.test$dropped$tips #none as no tips on the tree are redundant

##for the log-transformed data
eucs.log.obj <- eucs.log.obj <- comparative.data(phy = eucs.test.tree, data = eucs.log.data, names.col = taxon, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE)
eucs.log.obj$dropped$unmatched.rows #same 5 taxa as above so all good

##for the scaled data
eucs.scaled.obj <- comparative.data(phy = eucs.test.tree, data = eucs.scaled.data, names.col = taxon, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE)
eucs.scaled.obj$dropped$unmatched.rows #same 5 so all good

# for comparing among sprouters only without obligate seeders
eucs.sprout.obj <- comparative.data(phy = eucs.test.tree, data = eucs.data.sprouters, names.col = taxon, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE)
eucs.sprout.obj$dropped$unmatched.rows #now only the two taxa that were in the original tree but not on the new one: bunyip and carolaniae
eucs.sprout.obj$dropped$tips #12 tips of non- or not-sure-if- sprouters that come from the 10 NA plus 5 obs minus the three NA not on the tree at all.

#will leave the stem-only sprouter in there bc stem sprouting will be useful later.

#to use that data in its scaled form need to subset the scaled data table as well
eucs.scaled.sprouters <- eucs.scaled.data[is.sprouter, ] #the scaled values remain on the axis where the average includes the obseeders as well because we're ideally trying to place these taxa on universal spectra of possible trait values
eucs.scaled.sprout.obj <- comparative.data(phy = eucs.test.tree, data = eucs.scaled.sprouters, names.col = taxon, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE)
eucs.sprout.obj$dropped$tips
#eucs.sprout.obj$dropped$tips == eucs.sprout.obj$dropped$tips #all good same 
```



## Trait-Trait Correlations

###### Max Height


```{r}
max.height.rh <- pgls(max_height_m ~ relative_height_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(max.height.rh)
```


```{r}
max.height.std <- pgls(max_height_m ~ stem_density_g_per_ml, data = eucs.scaled.obj, lambda = 'ML')
summary(max.height.std)
# plot(max_height_m ~ stem_density_g_per_ml, data = eucs.scaled.data)
# abline(max.height.std)
```


```{r}
max.height.bark <- pgls(max_height_m ~ relative_bt_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(max.height.bark)
```


```{r}
max.height.sla <- pgls(max_height_m ~ sla_mm2_per_mg, data = eucs.scaled.obj, lambda = "ML")
summary(max.height.sla)
# plot(max_height_m ~ sla_mm2_per_mg, data = eucs.scaled.data)
# abline(max.height.sla)
```
 

```{r}
max.height.sla.2 <- pgls(max_height_m ~ sla_mm2_per_mg, data = eucs.test, lambda = "ML")
summary(max.height.sla.2)
```


```{r}
max.height.lfa <- pgls(max_height_m ~ leaf_area_cm2, data = eucs.scaled.obj, lambda = "ML")
summary(max.height.lfa)
# plot(max_height_m ~ leaf_area_cm2, data = eucs.scaled.data)
# abline(max.height.lfa)
```


```{r}
max.height.lms <- pgls(max_height_m ~ leaf_mass_g, data = eucs.scaled.obj, lambda = "ML")
summary(max.height.lms)
```



```{r}
max.height.fms <- pgls(max_height_m ~ fruit_mass_mg, data = eucs.scaled.obj, lambda = "ML", bounds = list(lambda = c(0.0001, 1), kappa = c(1e-6, 3), delta = c(1e-6, 3)))
summary(max.height.fms)
```



```{r}
max.height.fwl <- pgls(max_height_m ~ fruit_wall_width_mm, data = eucs.scaled.obj, lambda = "ML")
summary(max.height.fwl)
```



```{r}
max.height.sms <- pgls(max_height_m ~ seed_mass_mg, data = eucs.scaled.obj, lambda = "ML")
summary(max.height.sms)
```

###### Relative Height


```{r}
rel.height.mh <- pgls(relative_height_by_girth ~ max_height_m, data = eucs.scaled.obj, lambda = 'ML')
summary(rel.height.mh)
```

```{r}
rel.height.std <- pgls(relative_height_by_girth ~ stem_density_g_per_ml, data = eucs.scaled.obj, lambda = 'ML')
summary(rel.height.std)
```

```{r}
rel.height.bark <- pgls(relative_height_by_girth ~ relative_bt_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(rel.height.bark)
```

```{r}
rel.height.sla <- pgls(relative_height_by_girth ~ sla_mm2_per_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(rel.height.sla)
```

```{r}
rel.height.lfa <- pgls(relative_height_by_girth ~ leaf_area_cm2, data = eucs.scaled.obj, lambda = 'ML')
summary(rel.height.lfa)
```

```{r}
rel.height.lms <- pgls(relative_height_by_girth ~ leaf_mass_g, data = eucs.scaled.obj, lambda = 'ML')
summary(rel.height.lms)
```

```{r}
rel.height.fms <- pgls(relative_height_by_girth ~ fruit_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(rel.height.fms)
```

```{r}
rel.height.fwl <- pgls(relative_height_by_girth ~ fruit_wall_width_mm, data = eucs.scaled.obj, lambda = 'ML')
summary(rel.height.fwl)
```

```{r}
rel.height.sms <- pgls(relative_height_by_girth ~ seed_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(rel.height.sms)
```


###### Stem Sapwood Density


```{r}
stem.density.mh <- pgls(stem_density_g_per_ml ~ max_height_m, data = eucs.scaled.obj, lambda = 'ML')
summary(stem.density.mh)
# plot(stem_density_g_per_ml ~ max_height_m, data = eucs.scaled.data, xlab = "Log-scaled Max. Height", ylab = "Log-scaled Stem Density")
# abline(stem.density.mh)
```


```{r}
stem.density.rh <- pgls(stem_density_g_per_ml ~ relative_height_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(stem.density.rh)
```



```{r}
stem.density.bark <- pgls(stem_density_g_per_ml ~ relative_bt_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(stem.density.bark)
```


```{r}
stem.density.sla <- pgls(stem_density_g_per_ml ~ sla_mm2_per_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(stem.density.sla)
# plot(stem_density_g_per_ml ~ sla_mm2_per_mg, data = eucs.scaled.data, xlab = "Log-scaled SLA", ylab = "Log-scaled Stem Density")
# abline(stem.density.sla)
```


```{r}
stem.density.lfa <- pgls(stem_density_g_per_ml ~ leaf_area_cm2, data = eucs.scaled.obj, lambda = 'ML')
summary(stem.density.lfa)
```


```{r}
stem.density.lms <- pgls(stem_density_g_per_ml ~ leaf_mass_g, data = eucs.scaled.obj, lambda = 'ML', bounds = list(lambda = c(0.0001, 1), kappa = c(1e-6, 3), delta = c(1e-6, 3)))
summary(stem.density.lms)
```


```{r}
stem.density.fwl <- pgls(stem_density_g_per_ml ~ fruit_wall_width_mm, data = eucs.scaled.obj, lambda = 'ML')
summary(stem.density.fwl)
```


```{r}
stem.density.fms <- pgls(stem_density_g_per_ml ~ fruit_mass_mg, data = eucs.scaled.obj, lambda = 'ML', bounds = list(lambda = c(0.0001, 1), kappa = c(1e-6, 3), delta = c(1e-6, 3)))
summary(stem.density.fms)
```


```{r}
stem.density.sms <- pgls(stem_density_g_per_ml ~ seed_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(stem.density.sms)
```


###### Relative Bark Thickness


```{r}
bark.mh <- pgls(relative_bt_by_girth ~ max_height_m, data = eucs.scaled.obj, lambda = 'ML')
summary(bark.mh)
```


```{r}
bark.rh <- pgls(relative_bt_by_girth ~ relative_height_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(bark.rh)
```


```{r}
bark.std <- pgls(relative_bt_by_girth ~ stem_density_g_per_ml, data = eucs.scaled.obj, lambda = 'ML')
summary(bark.std)
```



```{r}
bark.sla <- pgls(relative_bt_by_girth ~ sla_mm2_per_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(bark.sla)
```


```{r}
bark.lfa <- pgls(relative_bt_by_girth ~ leaf_area_cm2, data = eucs.scaled.obj, lambda = 'ML')
summary(bark.lfa)
```


```{r}
bark.lms <- pgls(relative_bt_by_girth ~ leaf_mass_g, data = eucs.scaled.obj, lambda = 'ML')
summary(bark.lms)
```


```{r}
bark.fms <- pgls(relative_bt_by_girth ~ fruit_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(bark.fms)
```


```{r}
bark.fwl <- pgls(relative_bt_by_girth ~ fruit_wall_width_mm, data = eucs.scaled.obj, lambda = 'ML')
summary(bark.fwl)
```


```{r}
bark.sms <- pgls(relative_bt_by_girth ~ seed_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(bark.sms)
```



###### SLA

```{r}
sla.mh <- pgls(sla_mm2_per_mg ~ max_height_m, data = eucs.scaled.obj, lambda = 'ML')
summary(sla.mh)
# plot(sla_mm2_per_mg ~ max_height_m, data= eucs.scaled.data, xlab = "Log-scaled Max. Height", ylab = "Log-scaled SLA")
# abline(sla.mh)
```


```{r}
sla.rh <- pgls(sla_mm2_per_mg ~ relative_height_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(sla.rh)
```


```{r}
sla.std <- pgls(sla_mm2_per_mg ~ stem_density_g_per_ml, data = eucs.scaled.obj, lambda = 'ML')
summary(sla.std)
```


```{r}
sla.bark <- pgls(sla_mm2_per_mg ~ relative_bt_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(sla.bark)
```


```{r}
sla.lfa <- pgls(sla_mm2_per_mg ~ leaf_area_cm2, data = eucs.scaled.obj, lambda = 'ML')
summary(sla.lfa)
```


```{r}
sla.lms <- pgls(sla_mm2_per_mg ~ leaf_mass_g, data = eucs.scaled.obj, lambda = 'ML', bounds = list(lambda = c(0.0001, 1), kappa = c(1e-6, 3), delta = c(1e-6, 3))) #needed to specify slightly narrower bound due to the optimisation error
summary(sla.lms)
```


```{r}
sla.fwl <- pgls(sla_mm2_per_mg ~ fruit_wall_width_mm, data = eucs.scaled.obj, lambda = 'ML')
summary(sla.fwl)
```


```{r}
sla.fms <- pgls(sla_mm2_per_mg ~ fruit_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(sla.fms)
```


```{r}
sla.sms <- pgls(sla_mm2_per_mg ~ seed_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(sla.sms)
```


###### Leaf Area



```{r}
leaf.area.mh <- pgls(leaf_area_cm2 ~ max_height_m, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.area.mh)
```
 
 
```{r}
leaf.area.rh <- pgls(leaf_area_cm2 ~ relative_height_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.area.rh)
```


```{r}
leaf.area.std <- pgls(leaf_area_cm2 ~ stem_density_g_per_ml, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.area.std)
```


```{r}
leaf.area.sla <- pgls(leaf_area_cm2 ~ sla_mm2_per_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.area.sla)
# plot(leaf_area_cm2 ~ sla_mm2_per_mg, data = eucs.scaled.data)
# abline(leaf.area.sla)
```


```{r}
leaf.area.bark <- pgls(leaf_area_cm2 ~ relative_bt_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.area.bark)
```


```{r}
leaf.area.lms <- pgls(leaf_area_cm2 ~ leaf_mass_g, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.area.lms)
# plot(leaf_area_cm2 ~ leaf_mass_g, data = eucs.scaled.data, xlab="Log-scaled Leaf Mass", ylab="Log-scaled Leaf Area")
# abline(leaf.area.lms)
```


```{r}
leaf.area.fwl <- pgls(leaf_area_cm2 ~ fruit_wall_width_mm, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.area.fwl)
```


```{r}
leaf.area.fms <- pgls(leaf_area_cm2 ~ fruit_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.area.fms)
```


```{r}
leaf.area.sms <- pgls(leaf_area_cm2 ~ seed_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.area.sms)
```



###### Leaf Mass


```{r}
leaf.mass.mh <- pgls(leaf_mass_g ~ max_height_m, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.mass.mh)
```


```{r}
leaf.mass.rh <- pgls(leaf_mass_g ~ relative_height_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.mass.rh)
```


```{r}
leaf.mass.std <- pgls(leaf_mass_g ~ stem_density_g_per_ml, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.mass.std)
```


```{r}
leaf.mass.bark <- pgls(leaf_mass_g ~ relative_bt_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.mass.bark)
```


```{r}
leaf.mass.sla <- pgls(leaf_mass_g ~ sla_mm2_per_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.mass.sla)
```


```{r}
leaf.mass.lfa <- pgls(leaf_mass_g ~ leaf_area_cm2, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.mass.lfa)
```


```{r}
leaf.mass.fwl <- pgls(leaf_mass_g ~ fruit_wall_width_mm, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.mass.fwl)
```


```{r}
leaf.mass.fms <- pgls(leaf_mass_g ~ fruit_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.mass.fms)
# plot(leaf_mass_g ~ fruit_mass_mg, data = eucs.scaled.data, xlab = "Log-scaled Fruit Mass", ylab = "Log-scaled  Leaf Mass")
# abline(leaf.mass.fms)
```


```{r}
leaf.mass.sms <- pgls(leaf_mass_g ~ seed_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(leaf.mass.sms)
```



###### Fruil Wall Width


```{r}
fruit.wall.mh <- pgls(fruit_wall_width_mm ~ max_height_m, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.wall.mh)
```


```{r}
fruit.wall.rh <- pgls(fruit_wall_width_mm ~ relative_height_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.wall.rh)
```


```{r}
fruit.wall.std <- pgls(fruit_wall_width_mm ~ stem_density_g_per_ml, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.wall.std)
```


```{r}
fruit.wall.bark <- pgls(fruit_wall_width_mm ~ relative_bt_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.wall.bark)
```


```{r}
fruit.wall.sla <- pgls(fruit_wall_width_mm ~ sla_mm2_per_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.wall.sla)
```


```{r}
fruit.wall.lfa <- pgls(fruit_wall_width_mm ~ leaf_area_cm2, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.wall.lfa)
```


```{r}
fruit.wall.lms <- pgls(fruit_wall_width_mm ~ leaf_mass_g, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.wall.lms)
```


```{r}
fruit.wall.fms <- pgls(fruit_wall_width_mm ~ fruit_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.wall.fms)
# plot(fruit_wall_width_mm ~ fruit_mass_mg, data = eucs.scaled.data, xlab = "Log-scaled Fruit Mass", ylab = "Log-scaled Fruit Wall Width")
# abline(fruit.wall.fms)
```


```{r}
fruit.wall.sms <- pgls(fruit_wall_width_mm ~ seed_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.wall.sms)
# plot(fruit_wall_width_mm ~ seed_mass_mg, data=eucs.scaled.data, xlab="Log-scaled Seed Mass", ylab="Log-scaled Fruit Wall Width")
# abline(fruit.wall.sms)
```



###### Fruit Mass


```{r}
fruit.mass.mh <- pgls(fruit_mass_mg ~ max_height_m, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.mass.mh)
```


```{r}
fruit.mass.rh <- pgls(fruit_mass_mg ~ relative_height_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.mass.rh)
```


```{r}
fruit.mass.std <- pgls(fruit_mass_mg ~ stem_density_g_per_ml, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.mass.std)
```


```{r}
fruit.mass.bark <- pgls(fruit_mass_mg ~ relative_bt_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.mass.bark)
```


```{r}
fruit.mass.sla <- pgls(fruit_mass_mg ~ sla_mm2_per_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.mass.sla)
```
 

```{r}
fruit.mass.lfa <- pgls(fruit_mass_mg ~ leaf_area_cm2, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.mass.lfa)
```


```{r}
fruit.mass.lms <- pgls(fruit_mass_mg ~ leaf_mass_g, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.mass.lms)
```


```{r}
fruit.mass.fwl <- pgls(fruit_mass_mg ~ fruit_wall_width_mm, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.mass.fwl)
```


```{r}
fruit.mass.sms <- pgls(fruit_mass_mg ~ seed_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(fruit.mass.sms)
```


###### Seed Mass


```{r}
seed.mass.mh <- pgls(seed_mass_mg ~ max_height_m, data = eucs.scaled.obj, lambda = 'ML')
summary(seed.mass.mh)
```


```{r}
seed.mass.rh <- pgls(seed_mass_mg ~ relative_height_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(seed.mass.rh)
```


```{r}
seed.mass.std <- pgls(seed_mass_mg ~ stem_density_g_per_ml, data = eucs.scaled.obj, lambda = 'ML')
summary(seed.mass.std)
```


```{r}
seed.mass.bark <- pgls(seed_mass_mg ~ relative_bt_by_girth, data = eucs.scaled.obj, lambda = 'ML')
summary(seed.mass.bark)
```


```{r}
seed.mass.sla <- pgls(seed_mass_mg ~ sla_mm2_per_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(seed.mass.sla)
```


```{r}
seed.mass.lfa <- pgls(seed_mass_mg ~ leaf_area_cm2, data = eucs.scaled.obj, lambda = 'ML')
summary(seed.mass.lfa)
```


```{r}
seed.mass.lms <- pgls(seed_mass_mg ~ leaf_mass_g, data = eucs.scaled.obj, lambda = 'ML')
summary(seed.mass.lms)
```


```{r}
seed.mass.fwl <- pgls(seed_mass_mg ~ fruit_wall_width_mm, data = eucs.scaled.obj, lambda = 'ML')
summary(seed.mass.fwl)
```


```{r}
seed.mass.fms <- pgls(seed_mass_mg ~ fruit_mass_mg, data = eucs.scaled.obj, lambda = 'ML')
summary(seed.mass.fms)
# plot(seed_mass_mg ~ fruit_mass_mg, data = eucs.scaled.data, xlab="Log-scaled Fruit Mass", ylab="Log-scaled Seeed Mass")
# abline(seed.mass.fms)
```

So it appears that leaf mass and the reproductive traits are all positively correlated. This makes sense if we think of corner's rules (i.e. the relationships between leaf mass and fruit mass due to them being supported by the same branches with the same mechanical limitations on the sieze of appendage they can support) and, since the reproductive traits are all strongly correlated to one another, the correlation LM experiences with the other reproductive traits can be safely thought of as a resiual correlation. Similar residual correlation can be thought of between leaf area and the reproductive traits, since leaf area is strongly correlated to leaf mass because both traits are measures of leaf size.


Are there any correlations for which the calculated lambda value is not significantly different from 



# Plots


## Extracting Coefficients from PGLS Models

In order to create a dataframe of every model we want to represent in our 10 x 10 table we need to find a model to stand in for the main diagonal elements (traits correlated with themselves) that would have a coefficient of 1.00 and an r-squared of 1.00 also. We only need a single model for this and we can recycle this object for every trait's perfect fit with itself, since the results would be the same regardless of the trait being considered.
 
```{r}
#to regress a variable with itself, it needs to be regressed against another variable with a different name but the same datapoints, since the regression functions don't allow the regression of variables with the same name
eucs.scaled.data.doubled <- cbind(eucs.scaled.data, eucs.scaled.data[c("max_height_m", "relative_height_by_girth", "stem_density_g_per_ml", "relative_bt_by_girth", "sla_mm2_per_mg", "leaf_area_cm2", "leaf_mass_g", "fruit_mass_mg", "fruit_wall_width_mm", "seed_mass_mg")])

#now to rename the columns
names(eucs.scaled.data.doubled) <- c("taxon", "location", "second_location", "max_height_m", "relative_height_by_girth", "stem_density_g_per_ml", "relative_bt_by_girth", "sla_mm2_per_mg", "leaf_area_cm2", "leaf_mass_g", "fruit_mass_mg", "fruit_wall_width_mm", "seed_mass_mg", "Sprouter", "Stem_Sprouter", "Lignotuber_Sprouter", "Stem_Sprouter2", "Lignotuber_Only", "Sprouting_Type", "Sieberi", "max_height_m2", "relative_height_by_girth2", "stem_density_g_per_ml2", "relative_bt_by_girth2", "sla_mm2_per_mg2", "leaf_area_cm22", "leaf_mass_g2", "fruit_mass_mg2", "fruit_wall_width_mm2", "seed_mass_mg2")  

#now need to run models of variables against themselves so that r-squared (and slope coefficient) can be 1 and can be placed in the list wherever required
perfect.fit <- lm(max_height_m ~ max_height_m2, data = eucs.scaled.data.doubled)
names(perfect.fit$coefficients)[[2]] <- "max_height_m2" #to fix a new problem making the extract_P fucntion not work on this particular model becasue for some reason the variable had 'Y' at the end of its name in the coefficients dataframe from which the P-value is lifted
summary(perfect.fit)
```

Now to make the dataframe/matrix of all models in order to extract the coefficients.

```{r}
mh.list <- list(perfect.fit, max.height.rh, max.height.std, max.height.bark, max.height.sla, max.height.lfa, max.height.lms, max.height.fwl, max.height.fms, max.height.sms)

rh.list <- list(rel.height.mh, perfect.fit, rel.height.std, rel.height.bark, rel.height.sla, rel.height.lfa, rel.height.lms, rel.height.fwl, rel.height.fms, rel.height.sms)

stem.density.list <- list(stem.density.mh, stem.density.rh, perfect.fit, stem.density.bark, stem.density.sla, stem.density.lfa, stem.density.lms, stem.density.fwl, stem.density.fms, stem.density.sms)

bark.list <- list(bark.mh, bark.rh, bark.std, perfect.fit, bark.sla, bark.lfa, bark.lms, bark.fwl, bark.fms, bark.sms)

sla.list <- list(sla.mh, sla.rh, sla.std, sla.bark, perfect.fit, sla.lfa, sla.lms, sla.fwl, sla.fms, sla.sms)

leaf.area.list <- list(leaf.area.mh, leaf.area.rh, leaf.area.std, leaf.area.bark, leaf.area.sla, perfect.fit, leaf.area.lms, leaf.area.fwl, leaf.area.fms, leaf.area.sms)

leaf.mass.list <- list(leaf.mass.mh, leaf.mass.rh, leaf.mass.std, leaf.mass.bark, leaf.mass.sla, leaf.mass.lfa, perfect.fit, leaf.mass.fwl, leaf.mass.fms, leaf.mass.sms)

fruit.wall.list <- list(fruit.wall.mh, fruit.wall.rh, fruit.wall.std, fruit.wall.bark, fruit.wall.sla, fruit.wall.lfa, fruit.wall.lms, perfect.fit, fruit.wall.fms, fruit.wall.sms)

fruit.mass.list <- list(fruit.mass.mh, fruit.mass.rh, fruit.mass.std, fruit.mass.bark, fruit.mass.sla, fruit.mass.lfa, fruit.mass.lms, fruit.mass.fwl, perfect.fit, fruit.mass.sms)

seed.mass.list <- list(seed.mass.mh, seed.mass.rh, seed.mass.std, seed.mass.bark, seed.mass.sla, seed.mass.lfa, seed.mass.lms, seed.mass.fwl, seed.mass.fms, perfect.fit)

traits.list <- list(mh.list, rh.list, stem.density.list, bark.list, sla.list, leaf.area.list, leaf.mass.list, fruit.wall.list, fruit.mass.list, seed.mass.list)
```


Now to Extract the pseudo-r-squared to arrive at the pseudo-r-value by taking the square root and assigning a negative sign to those relationsips where the slope coefficient (here 'c') is negative.

```{r}
full.list <- lapply(traits.list, function(model.list){
  unlist(lapply(model.list, r_squared))
})

matrix.table.r2 <- data.frame('MH' = full.list[[1]], 'RH' = full.list[[2]], 'SD' = full.list[[3]], 'RBT' = full.list[[4]], 'SLA' = full.list[[5]], 'LA' = full.list[[6]], 'LM' = full.list[[7]], 'FWW' = full.list[[8]], 'FM' = full.list[[9]], 'SM' = full.list[[10]])

matrix.table.r <- as.data.frame(lapply(matrix.table.r2, sqrt))


#now to make sure that the signs of the correlations are correct by building similar dataframe but with slope coefficients

full.list.coeff <- lapply(traits.list, function(model.list){
  unlist(lapply(model.list, extract_slope))
})

matrix.table.c <- data.frame('MH' = full.list.coeff[[1]], 'RH' = full.list.coeff[[2]], 'SD' = full.list.coeff[[3]], 'RBT' = full.list.coeff[[4]], 'SLA' = full.list.coeff[[5]], 'LA' = full.list.coeff[[6]], 'LM' = full.list.coeff[[7]], 'FWW' = full.list.coeff[[8]], 'FM' = full.list.coeff[[9]], 'SM' = full.list.coeff[[10]])

neg.slopes <- matrix.table.c < 0
sum(neg.slopes)

matrix.table.r[neg.slopes] <- matrix.table.r[neg.slopes]*-1

matrix.table.r <- t(matrix.table.r)

matrix.r <- as.matrix(matrix.table.r)
colnames(matrix.r) <- rownames(matrix.table.r)
```


## Raw Data Plots

### Ellipse Table

```{r}
corrplot(matrix.r, method = "ellipse") #with pgls r-values

# pdf('pgls_ellipse_table.pdf')
# corrplot(matrix.r, method = "ellipse")
# mtext(text = "Dependent Variable", side = 2, line = 1)
# mtext(text = "Independent Variable", side = 3, line = 1)
# dev.off()
```



### Network Diagram

Shows the trait-relationships as a network or connected traits

```{r}
qgraph(matrix.r, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
```
Since the results for the parameters of the pgls models differ depending on which variable is comnsidered to be the dependent and which the independent variable, when we extract the pseudo-r2 (and also the slope coefficients) each pair of traits has two sets of parameters describing their relationship. This is likely the reason for this network diagram having twice as many lines as intended with two lines for each pairwise comparison of traits instead of one.

Hence, we need to choose a single model for each pairwise comparison so there are only one set of parameters and only a single line for the network diagram so it can be compared to the non-pgls diagram later.


### Lambda Matrix Plot

```{r, fig.height = 8, fig.width = 10}
# applying the extract_lambda function to a whole dataframe of models
full.lambda.list <- lapply(traits.list, function(model.list) {
  lambda.list <- lapply(model.list, extract_lambda)
  lambda.list[unlist(lapply(lambda.list, is.null))] <- NA
  unlist(lambda.list)
})

lambda.frame <- as.data.frame(full.lambda.list)
colnames(lambda.frame) <- colnames(matrix.table.r2)
lambda.matrix <- as.matrix(lambda.frame)
lambda.matrix <- t(lambda.matrix)
colnames(lambda.matrix) <- rownames(lambda.matrix)

par(mar = c(5.1, 4.1, 4.1, 4.1))
plot(lambda.matrix, col = heat.colors(30, rev = TRUE), breaks = 30, na.col= "black", key = list(side = 1, cex.axis = 1.00), fmt.key="%.3f", xlab = "", ylab = "", main = "", axis.col = list(side = 3), fmt.cell='%.3f')
plot(lambda.matrix, col = heat.colors(30, rev = TRUE), breaks = 30, na.col= "black", key = list(side = 1, cex.axis = 1.00), fmt.key="%.3f", xlab = "", ylab = "", main = "", axis.col = list(side = 3))


# OR JUST USE THE CORRPLOT FUCTION WITHOUT ELLIPSES
corrplot(lambda.matrix, method = 'color') #this is only positive so the difference between the colours isn't great and can be hard to see

# #now to export this figure
# pdf('lambda_colour_tables.pdf')
# plot(lambda.matrix, col = heat.colors(30, rev = TRUE), breaks = 30, na.col= "black", key = list(side = 1, cex.axis = 1.00), fmt.key="%.3f", xlab = "Independent Variable", ylab = "Dependent Variable", main = "", axis.col = list(side = 3))
# plot(lambda.matrix, col = heat.colors(30, rev = TRUE), breaks = 30, na.col= "black", key = list(side = 1, cex.axis = 1.00), fmt.key="%.3f", xlab = "Independent Variable", ylab = "Dependent Variable", main = "", axis.col = list(side = 3), fmt.cell='%.3f')
# dev.off()
```


## Symmetrical Data Plots

Making the network diagram less busy, more comparable and making the correlation coefficient matrix symmetrical for the ellipse table requires choosing which variable would be best to be the (in)dependent variable for each comparison and chosing one of the models. We decided that the it is more conservative to consider the model for which the lambda value was higher meant that more f the phyogenetic signal in both trait was being accounted for (usually when the more conserved trait was the dependent variable).


### Halving the pgls data

So now we will try to make a matrix of both lambda and r-2 such that only the arrangement of dep-indep variables with the highest lambda is included in the eventual matrix.

If we can make a logical matrix or data frame such that the entries of lambda are larger than their reciprocal then maybe have a blank matrix of zeros and have the entries in the position of that logical vector be replaced by the lambda matrix entries. Then we'd have to write another function that replaces the remaining values by adding maybe the transpose of the matrix itself.

Turns out there's an upper.tri(m) function for creating a logical that extracts the halves excluding the main diagonal unless diag = TRUE.

```{r}
#in order to determine which models have higher lambda than ther reciprocal relationships
extract_highest_lambda <- function(square.matrix) { #creates a logical vector of which cells in a matrix have values that are higher than those of their reflected positions
  logical <- matrix(NA, dim(square.matrix)[1], dim(square.matrix)[2])
for (i in 1:dim(square.matrix)[1]){
  for (j in 1:dim(square.matrix)[2]) {
     logical[i,j] <- square.matrix[i,j] > square.matrix[j,i]
  }
}
  if (sum(logical == t(logical), na.rm = TRUE) != 0) {
    print("WARNING: some cells are equal to their reciprocal positions!") #delivers warning when there are some that are equal instead of having one cell value be larger or smaller than that of it its reciprocal position in the matrix
  }
  return(logical)
}
#to check if there are places where lambda was equal for both arrangements
log1 <- extract_highest_lambda(lambda.matrix)
sum(log1 == t(log1), na.rm = TRUE) #each pair of models with equal values when axes are swapped contributes 2 to this total, hence there is only one model like that
log1 == t(log1) #this reveals where they are in the matrix
#in this case it appears that leaf mass and relative height are the trait in those 2 models and I'll decide to go with the one with leaf mass as the dependent variable
log1[7,2] <- TRUE #now they're all mirrored pairs are either larger or smaller than one another
log1
sum(!log1 != t(log1), na.rm = TRUE) #this proves that this matrix is such that it's reciprocal equals its 
log2 <- log1
log2[is.na(log2)] <- FALSE
log3 <- !log1
log3[is.na(log3)] <- FALSE
!log2



lambda.half <- matrix(NA, 10, 10)
lambda.half[log2] <- lambda.matrix[log2]
lambda.half[log3] <- t(lambda.matrix)[log3]
rownames(lambda.half) <- rownames(lambda.matrix)
colnames(lambda.half) <- rownames(lambda.half)

matrix.r2.half <- matrix(NA, 10, 10) 
matrix.r2.half[log2] <- t(as.matrix(matrix.table.r2))[log2] #carefull to be wary of the fact that the x and y axes of these are reversed so col = dep var and row = indep var
matrix.r2.half[!log2] <- as.matrix(matrix.table.r2)[!log2] 
rownames(matrix.r2.half) <- colnames(matrix.table.r2)
colnames(matrix.r2.half) <- rownames(matrix.r2.half)

matrix.r.half <- sqrt(matrix.r2.half)


matrix.coeff.half <- matrix(NA, 10, 10)
matrix.coeff.half[log2] <- t(as.matrix(matrix.table.c))[log2] #carefull to be wary of the fact that the x and y axes of these are reversed so col = dep var and row = indep var
matrix.coeff.half[!log2] <- as.matrix(matrix.table.c)[!log2] 
rownames(matrix.coeff.half) <- colnames(matrix.table.c)
colnames(matrix.coeff.half) <- rownames(matrix.coeff.half)

neg.slopes.half <- matrix.coeff.half < 0

matrix.r.half[neg.slopes.half] <- matrix.r.half[neg.slopes.half]*-1
```

### New Lambda Matrix

```{r}
# new matrix
plot(lambda.half, col = heat.colors(10, rev = TRUE), breaks = c(0.400, 0.450, 0.500, 0.550, 0.600, 0.650, 0.700, 0.750, 0.800, 0.850, 0.900), na.col= "black", key = list(side = 1, cex.axis = 1.00), fmt.key="%.3f", xlab = "", ylab = "", main = "", axis.col = list(side = 3), asp = TRUE)
#corrplot(as.matrix(delta.r2.half), method = 'color')

#cmopare with raw lambda matrix:
plot(lambda.matrix, col = heat.colors(30, rev = TRUE), breaks = 30, na.col= "black", key = list(side = 1, cex.axis = 1.00), fmt.key="%.3f", xlab = "", ylab = "", main = "", axis.col = list(side = 3), asp = TRUE)
#corrplot(as.matrix(delta.r2), method = 'color')
```


### Network Diagrams

```{r}
#so for the new comparison for the network diagrams
qgraph(matrix.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
qgraph(matrix.r, layout = 'spring', label.cex = 0.9, label.scale = FALSE)

qgraph(matrix.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
#qgraph(table.matrix, layout = 'spring', label.cex = 0.9, label.scale = FALSE) #table matrix comes from the olm models and so is already symmetrical in its R and R-squared values


# TO EXPORT:

# network.diagram.pgls.half <- qgraph(matrix.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
# network.diagram.olm <- qgraph(table.matrix, layout = 'spring', label.cex = 0.9, label.scale = FALSE)

#qgraph(network.diagram.pgls.half, filetype = 'pdf', filename = "pgls_network", height = 15, width = 20, labels = colnames(matrix.r.half), label.cex = 2)
#qgraph(network.diagram.olm, filetype = 'pdf', filename = "olm_network", height = 15, width = 20, labels = colnames(table.matrix), label.cex = 2)
```


#### Only Significant Relations

The above network diagram is still too busy so only showing the relationships that are statistically significant.

##### Reformatting the data

```{r fig.height = 8, fig.width = 10}
#need to find a funciton that extracts P-values from each model
pgls.P <- lapply(traits.list, function(model.list){
  unlist(lapply(model.list, extract_P))
})
class(mh.list)
extract_P(perfect.fit)
# x$coefficients[,c('Pr(>|t|)')]
# x$call$formula
# x<- summary(perfect.fit)
# x$coefficients[c(as.character(x$call$formula[[3]])), c("Pr(>|t|)")]
pgls.P <- as.data.frame(pgls.P)
colnames(pgls.P) <- colnames(matrix.r)
row.names(pgls.P) <- colnames(pgls.P)
pgls.P <- t(pgls.P) #now it's around the right way with the row indicating the dependent variable and colun the independent variable
pgls.P 

all.equal(pgls.P, t(pgls.P)) #not simply computationaly different so not symmetrical at all

pgls.P.half <- matrix(NA, 10, 10) 
pgls.P.half[log2] <- t(as.matrix(pgls.P))[log2] #careful to be wary of the fact that the x and y axes of these are reversed so col = dep var and row = indep var
pgls.P.half[!log2] <- as.matrix(pgls.P)[!log2] 
rownames(pgls.P.half) <- colnames(matrix.r)
colnames(pgls.P.half) <- rownames(pgls.P.half)
pgls.P.half

sig.models <- pgls.P < 0.05 #non-symmetrical
#sig.models == sig.models.P #compare with previous non-symmetrical manually enetered version (code below), both are the correct way around so the comparison is valid
#the change in significance from using this new median-creating method is in the LM-RBT relationship becoming non-significant but the other axis arrangement had the higher lambda anyway and was already non-signifiant

#manual assignment of significance from when I couldn't figure out how to 
#sig.models <- data.frame('MH' = c(1,1,0,1,1,1,1,0,0,0), 'RH' = c(1,1,0,0,1,1,1,0,0,0), 'SD' = c(0,0,1,1,1,1,0,0,0,0), 'RBT' = c(1,1,1,1,1,1,1,1,1,0), 'SLA' = c(1,1,1,1,1,0,1,1,1,1), 'LA' = c(1,1,1,1,0,1,1,1,1,1), 'LM' = c(0,1,0,0,1,1,1,1,1,1), 'FWW' = c(0,0,0,1,1,1,1,1,1,1), 'FM' = c(0,0,0,1,1,1,1,1,1,1), 'SM' = c(0,0,0,0,1,1,1,1,1,1))
#NOTE: since the above table was filled out manually, it is already the correct way around

# when grampians SD are excluded, the SD ~ MH becomes non significant and the SD ~ LA and LA ~ SD relationships become significant

row.names(sig.models) <- colnames(sig.models)
sig.models <- sig.models == 1
sig.netlines <- t(matrix.table.r2) #since matrix.table.r2 is the wrong way around
sig.netlines[!sig.models] <- 0

#now to repeat the symmetry-inducing model-choosing as above
sig.only.r2.half <- matrix(NA, 10, 10)
sig.only.r2.half[log2] <- as.matrix(sig.netlines)[log2]
sig.only.r2.half[!log2] <- t(as.matrix(sig.netlines))[!log2]
rownames(sig.only.r2.half) <- rownames(sig.netlines)
colnames(sig.only.r2.half) <- rownames(sig.netlines)

sig.only.r.half <- sqrt(sig.only.r2.half)
sig.only.r.half[neg.slopes.half] <- sig.only.r.half[neg.slopes.half]*-1
```


Comparing the sig-only version of the network diagram to the previous that contained all the lines:

```{r}
qgraph(matrix.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
qgraph(sig.only.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
```
Saving/Exporting the figures:

```{r}
network.diag.pgls.sig <- qgraph(sig.only.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)

qgraph(network.diag.pgls.sig, filetype = 'pdf', filename = "Output_figures/pgls_network_sig_only", height = 15, width = 20, labels = colnames(matrix.r.half), label.cex = 2)
```

This will need some fiddling in order to mnually jitter some of the nodes so that the lines are visible and not obscuring anything.


##### Final Network Diagrams

```{r}
#qgraph(sig.only.r.olm, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
#qgraph(table.matrix, layout = 'spring', label.cex = 0.9, label.scale = FALSE)

#network.diag.olm.sig <- qgraph(sig.only.r.olm, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
#network.diag.pgls.sig <- qgraph(sig.only.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)

#qgraph(sig.only.r.olm, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
qgraph(sig.only.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)

#qgraph(network.diag.pgls.sig, filetype = 'pdf', filename = "pgls_network_sig_only", height = 15, width = 20, labels = colnames(matrix.r.half), label.cex = 2)
#qgraph(network.diag.olm.sig, filetype = 'pdf', filename = "olm_network_sig_only", height = 15, width = 20, labels = colnames(matrix.r.half), label.cex = 2)
```

Some of these lines are a bit misleading when they pass through SLA so I need to move the SLA node slightly out of the way of those lines.

```{r}

```


### Only r > 0.2

```{r}
sig.only.r.half2 <- sig.only.r.half
sig.only.r.half2[abs(sig.only.r.half2) < 0.2] <- 0 #6 entries => 3 relationships lost to

qgraph(sig.only.r.half2, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
qgraph(sig.only.r.half, layout = 'spring', label.cex = 0.9, label.scale = FALSE)
```



## Data for Tables


```{r}
#for tables at the end:
matrix.r2.half #symmetrical version using only some of them for the tables at the end

matrix.coeff.half

pgls.coeff.SE <- lapply(traits.list, function(model.list){
  unlist(lapply(model.list, extract_SE))
})

pgls.coeff.SE <- as.data.frame(pgls.coeff.SE)
colnames(pgls.coeff.SE) <- colnames(matrix.r)
row.names(pgls.coeff.SE) <- colnames(pgls.coeff.SE)
pgls.coeff.SE <- t(pgls.coeff.SE)

  #now to make it a half one
pgls.coeff.SE.half <- matrix(NA, 10, 10) 
pgls.coeff.SE.half[log2] <- t(as.matrix(pgls.coeff.SE))[log2] #carefull to be wary of the fact that the x and y axes of these are reversed so col = dep var and row = indep var
pgls.coeff.SE.half[!log2] <- as.matrix(pgls.coeff.SE)[!log2] 
rownames(pgls.coeff.SE.half) <- colnames(matrix.r)
colnames(pgls.coeff.SE.half) <- rownames(pgls.coeff.SE.half)
pgls.coeff.SE.half

lambda.half

pgls.n <- lapply(traits.list, function(model.list){
  unlist(lapply(model.list, extract_n))
})

pgls.n <- as.data.frame(pgls.n)
colnames(pgls.n) <- colnames(matrix.r)
row.names(pgls.n) <- colnames(pgls.n)
pgls.n <- t(pgls.n) #now it's around the right way with the row indicating the dependent variable and colun the independent variable
pgls.n #naturally symetrical
pgls.n +2 #actual sample size
```

```{r}
#for knowing min and max values, need full original tables
pgls.r2 <- matrix.r^2
sort(pgls.r2)

max(pgls.r2[pgls.r2<1])

sort(as.matrix(matrix.table.c))
class(matrix.table.c)
row.names(matrix.table.c) <- colnames(matrix.table.c)
sort(abs(unlist(matrix.table.c)))

diag(pgls.n) <- 0
min(pgls.n[pgls.n > 0])
diag(olm.n) <- 0
olm.n == pgls.n

#degrees of freedom are different between the ols and pgls analyses, this is because 5 non-tree taxa are included in thetips analysis but are not in the pgls version

pgls.n == olm.n #they're equal now that i've removed the 5 non-tree taxa from the tips analysis
olm.n

matrix.table.c

plot.data <- data.frame("r2" = unlist(as.data.frame(pgls.r2)), "C" = unlist(as.data.frame(matrix.table.c)), "Abs_C" = abs(unlist(as.data.frame(matrix.table.c))))
plot(Abs_C ~ r2, plot.data)


sort(lambda.matrix[lambda.matrix > 0.1])
median(sort(lambda.matrix[lambda.matrix > 0.1]))
mean(sort(lambda.matrix[lambda.matrix > 0.1]))

sort(abs(olm.coeff))

sig.only.r.olm
sig.only.r.half

median(lambda.matrix, na.rm = TRUE)
sort(as.matrix(matrix.table.r2))

sort(abs(as.matrix(matrix.table.c)))
```

